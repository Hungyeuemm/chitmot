<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Love - Memory Pro Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #header {
            position: absolute; top: 30px; width: 100%;
            text-align: center; color: #FFD700;
            font-family: "Georgia", serif;
            font-size: clamp(24px, 6vw, 60px); font-weight: bold;
            pointer-events: none; text-shadow: 0 0 20px #FFD700;
            letter-spacing: 5px; z-index: 10;
            opacity: 0; transition: opacity 3s ease-in;
        }
        #loveText {
            position: absolute; top: 75%; width: 100%;
            text-align: center; color: #FF4500;
            font-family: "Brush Script MT", cursive;
            font-size: clamp(35px, 7vw, 90px); font-weight: bold;
            pointer-events: none; text-shadow: 0 0 30px #FFD700;
            z-index: 10; opacity: 0; padding-right: 80px;
        }
        #startOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); display: flex; justify-content: center; align-items: center;
            z-index: 1000; cursor: pointer; color: #FFD700; font-family: serif;
            flex-direction: column; transition: opacity 1s;
        }
        #letterContent {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 85%; max-width: 500px; background: rgba(255, 255, 255, 0.98);
            padding: 40px; border-radius: 20px; box-shadow: 0 0 60px rgba(255, 69, 0, 0.4);
            display: none; z-index: 2000; color: #2c3e50; font-family: 'Courier New', Courier, monospace;
            line-height: 1.8; font-size: 18px; text-align: left; border: 3px solid #FF4500;
        }
        .close-btn { position: absolute; top: 10px; right: 15px; cursor: pointer; font-size: 30px; color: #e74c3c; }
    </style>
</head>

<body>
    <div id="startOverlay">
        <h1>NHẤN ĐỂ MỞ QUÀ</h1>
        <p>(Cùng khám phá nhaaa...)</p>
    </div>

    <div id="header">MERRY CHRISTMAS 2025</div>
    <div id="loveText">I LOVE YOU</div>

    <div id="letterContent">
        <span class="close-btn" onclick="closeLetter()">×</span>
        <div id="typewriter"></div>
    </div>

    <audio id="bgMusic" loop preload="auto">
        <source src="./Supersonixs_-_We_Wish_You_a_Merry_Christmas_Remix_(mp3.pm).mp3" type="audio/mpeg">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const music = document.getElementById('bgMusic');
        const overlay = document.getElementById('startOverlay');
        const letterBox = document.getElementById('letterContent');
        const typewriter = document.getElementById('typewriter');

        let experienceStarted = false;
        let isMorphed = false;
        let treeFinished = false;
        let letterOpened = false;
        let focusedPhoto = null;

        const message = "Gửi em yêu,\n\nGiáng sinh đến rồi. Anh chỉ muốn nói là anh rất vui vì có em trong cuộc sống của mình. Cảm ơn em vì đã ở bên anh theo cách rất tự nhiên. Chúc em một Noel yên bình, và mong rằng chúng ta sẽ còn cùng nhau đi tiếp.\n\nChúc em một năm mới bình an, mạnh khỏe và yêu anh hơn nhó!!\n\nMãi yêu em! ❤";

        const photoUrls = ["./Linh/ghedep1.jpg", "./Linh/IMG_1076.JPG", "./Linh/IMG_1850.JPG", "./Linh/IMG_1851.JPG", "./Linh/IMG_1852.JPG", "./Linh/Linhxing.jpg"];

        overlay.addEventListener('click', () => {
            music.play().catch(e => console.log("Live Server required"));
            overlay.style.opacity = '0';
            setTimeout(() => overlay.remove(), 1000);
            experienceStarted = true;
        });

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 6000);
        camera.position.set(0, 80, 280);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.autoRotate = true; controls.autoRotateSpeed = 0.5;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const palette = [0xFFD700, 0xFF4500, 0x00FF44, 0x00AAFF, 0xB8860B, 0xFF69B4, 0xFF0000];

        // --- 1. TẠO BAO THƯ ---
        function createEnvelopeTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff9e6'; ctx.fillRect(0, 0, 256, 256);
            ctx.strokeStyle = '#FF4500'; ctx.lineWidth = 12; ctx.strokeRect(10, 10, 236, 236);
            ctx.beginPath(); ctx.moveTo(10, 10); ctx.lineTo(128, 130); ctx.lineTo(246, 10); ctx.stroke();
            ctx.fillStyle = '#FF4500'; ctx.beginPath(); ctx.arc(128, 130, 10, 0, Math.PI * 2); ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }
        const envelope = new THREE.Mesh(new THREE.PlaneGeometry(38, 26), new THREE.MeshBasicMaterial({ map: createEnvelopeTexture(), side: THREE.DoubleSide, transparent: true, opacity: 0 }));
        envelope.position.set(80, -35, 20); envelope.visible = false; scene.add(envelope);

        // --- 2. KHUNG ẢNH (Dùng chung Geometry) ---
        const photoGroup = new THREE.Group();
        const allPhotos = [];
        const textureLoader = new THREE.TextureLoader();
        const frameGeo = new THREE.PlaneGeometry(18, 24);
        const innerPhotoGeo = new THREE.PlaneGeometry(16, 22);

        function createPhotoFrame(url, x, z) {
            const group = new THREE.Group();
            const tex = textureLoader.load(url);
            const border = new THREE.Mesh(frameGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
            const photo = new THREE.Mesh(innerPhotoGeo, new THREE.MeshBasicMaterial({ map: tex }));
            photo.position.z = 0.1;
            group.add(border, photo);
            group.position.set(x, -64, z);
            group.rotation.x = -Math.PI / 2;
            group.rotation.z = Math.random() * Math.PI;
            group.scale.set(0, 0, 0); // Ban đầu nhỏ xíu
            group.userData = { originalPos: new THREE.Vector3(x, -64, z), originalRot: group.rotation.clone(), isPhoto: true };
            return group;
        }

        photoUrls.forEach((url, i) => {
            const angle = (i / photoUrls.length) * Math.PI * 2;
            const r = 110 + Math.random() * 80;
            const p = createPhotoFrame(url, Math.cos(angle) * r, Math.sin(angle) * r);
            photoGroup.add(p); allPhotos.push(p);
        });
        scene.add(photoGroup);

        // --- 3. VƯỜN HOA TỐI ƯU (Dùng chung Geometry) ---
        const petalGeo = new THREE.CircleGeometry(3.5, 8);
        const centerGeo = new THREE.SphereGeometry(1.5, 8, 8);
        const flowerGarden = new THREE.Group();

        function createFlower(x, y, z, color) {
            const group = new THREE.Group();
            const center = new THREE.Mesh(centerGeo, new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xFFD700, emissiveIntensity: 0.8 }));
            group.add(center);
            const petalMat = new THREE.MeshStandardMaterial({ color: color, side: THREE.DoubleSide, emissive: color, emissiveIntensity: 0.5 });
            for (let i = 0; i < 6; i++) {
                const p = new THREE.Mesh(petalGeo, petalMat);
                const a = (i / 6) * Math.PI * 2;
                p.position.set(Math.cos(a) * 3.5, 0, Math.sin(a) * 3.5);
                p.rotation.set(-Math.PI / 2, 0, a);
                group.add(p);
            }
            group.position.set(x, y, z);
            group.scale.set(0, 0, 0); // Ban đầu nhỏ xíu
            return group;
        }
        for (let i = 0; i < 120; i++) {
            const a = Math.random() * Math.PI * 2; const r = 60 + Math.random() * 220;
            const fl = createFlower(Math.cos(a) * r, -62, Math.sin(a) * r, palette[Math.floor(Math.random() * palette.length)]);
            flowerGarden.add(fl);
        }
        scene.add(flowerGarden);

        // --- CLICK HANDLER (Bay trực diện Fixed) ---
        window.addEventListener('mousedown', (event) => {
            if (!experienceStarted) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (focusedPhoto) {
                photoGroup.attach(focusedPhoto);
                gsap.to(focusedPhoto.position, { x: focusedPhoto.userData.originalPos.x, y: focusedPhoto.userData.originalPos.y, z: focusedPhoto.userData.originalPos.z, duration: 1.2, ease: "power2.inOut" });
                gsap.to(focusedPhoto.rotation, { x: focusedPhoto.userData.originalRot.x, y: focusedPhoto.userData.originalRot.y, z: focusedPhoto.userData.originalRot.z, duration: 1.2 });
                focusedPhoto = null; controls.autoRotate = true; return;
            }

            if (isMorphed && !letterOpened) {
                if (raycaster.intersectObject(envelope).length > 0) {
                    letterOpened = true;
                    gsap.to(envelope.rotation, { y: Math.PI * 2, duration: 1 });
                    gsap.to(envelope.material, { opacity: 0, duration: 0.5, onComplete: () => { letterBox.style.display = 'block'; startTypewriter(); } });
                    return;
                }
            }

            const intersects = raycaster.intersectObjects(allPhotos, true);
            if (intersects.length > 0 && treeFinished && !isMorphed) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.isPhoto) obj = obj.parent;
                focusedPhoto = obj; controls.autoRotate = false;
                scene.attach(obj);
                const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                const targetPos = new THREE.Vector3().copy(camera.position).add(camDir.multiplyScalar(75));
                gsap.to(obj.position, { x: targetPos.x, y: targetPos.y, z: targetPos.z, duration: 1.2, ease: "back.out(1.2)" });
                obj.lookAt(camera.position);
            }
        });

        // --- SHADERS & LAYERS ---
        const vertexShader = `attribute vec3 color; attribute vec3 aStartPos; attribute vec3 aHeartPos; uniform float uProgress; uniform float uSurprise; uniform float uPointSize; varying vec3 vColor; mat2 rotate2d(float a){ return mat2(cos(a), -sin(a), sin(a), cos(a)); } void main() { vColor = color; vec3 vPos = mix(aStartPos, position, uProgress); vPos.xz = rotate2d((1.0 - uProgress) * 15.0 * (1.0 - vPos.y * 0.015)) * vPos.xz; vec3 finalPos = mix(vPos, aHeartPos, uSurprise); vec4 mvPos = modelViewMatrix * vec4(finalPos, 1.0); gl_PointSize = uPointSize * (400.0 / -mvPos.z); gl_Position = projectionMatrix * mvPos; }`;
        const fragmentShader = `uniform sampler2D uTexture; uniform bool uUseTexture; varying vec3 vColor; void main() { if(uUseTexture) { vec4 tex = texture2D(uTexture, gl_PointCoord); if (tex.r < 0.1) discard; gl_FragColor = vec4(vColor * tex.rgb, tex.a); } else { float d = distance(gl_PointCoord, vec2(0.5)); if(d > 0.5) discard; gl_FragColor = vec4(vColor, 1.0 - smoothstep(0.3, 0.5, d)); } }`;

        function createIconTexture(type) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ffffff';
            if (type === 'heart') { ctx.beginPath(); ctx.moveTo(64, 104); ctx.bezierCurveTo(64, 96, 16, 76, 16, 48); ctx.bezierCurveTo(16, 20, 56, 20, 64, 40); ctx.bezierCurveTo(72, 20, 112, 20, 112, 48); ctx.bezierCurveTo(112, 76, 64, 96, 64, 104); ctx.fill(); }
            else { ctx.fillRect(24, 36, 80, 80); ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 8; ctx.strokeRect(60, 36, 8, 80); ctx.strokeRect(24, 72, 80, 8); ctx.beginPath(); ctx.arc(48, 24, 12, 0, Math.PI * 2); ctx.arc(80, 24, 12, 0, Math.PI * 2); ctx.stroke(); }
            return new THREE.CanvasTexture(canvas);
        }

        function createLayer(type, count, isGround = false) {
            const geo = new THREE.BufferGeometry();
            const endPos = new Float32Array(count * 3), startPos = new Float32Array(count * 3), heartPos = new Float32Array(count * 3), colors = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const hR = Math.random(), h = hR * 130, r = isGround ? Math.sqrt(Math.random()) * 450 : Math.pow(1.0 - hR, 1.5) * 65 * Math.sqrt(Math.random()), a = Math.random() * Math.PI * 2;
                endPos[i * 3] = Math.cos(a) * r; endPos[i * 3 + 1] = isGround ? -65 : h - 65; endPos[i * 3 + 2] = Math.sin(a) * r;
                const sR = 600 + Math.random() * 1000, sA = Math.random() * Math.PI * 2; startPos[i * 3] = Math.cos(sA) * sR; startPos[i * 3 + 1] = (Math.random() - 0.5) * 1200; startPos[i * 3 + 2] = Math.sin(sA) * sR;
                const t = Math.random() * Math.PI * 2; const sc = 3.8;
                heartPos[i * 3] = (16 * Math.pow(Math.sin(t), 3)) * sc; heartPos[i * 3 + 1] = (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) * sc + 20; heartPos[i * 3 + 2] = (Math.random() - 0.5) * 20;
                const c = isGround ? new THREE.Color(0xffffff) : new THREE.Color(palette[Math.floor(Math.random() * palette.length)]);
                colors[i * 3] = c.r; colors[i * 3 + 1] = c.g; colors[i * 3 + 2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(endPos, 3)); geo.setAttribute('aStartPos', new THREE.BufferAttribute(startPos, 3)); geo.setAttribute('aHeartPos', new THREE.BufferAttribute(heartPos, 3)); geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            return new THREE.Points(geo, new THREE.ShaderMaterial({ uniforms: { uProgress: { value: 0 }, uSurprise: { value: 0 }, uTexture: { value: isGround ? null : createIconTexture(type) }, uPointSize: { value: isGround ? 3.0 : 7.0 }, uUseTexture: { value: !isGround } }, vertexShader, fragmentShader, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }));
        }

        const spiralString = (function () {
            const geo = new THREE.BufferGeometry(); const count = 350; const pos = new Float32Array(count * 3), colors = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) { const p = i / count; const a = p * 5 * Math.PI * 2; const r = THREE.MathUtils.lerp(70, 10, p); pos[i * 3] = Math.cos(a) * r; pos[i * 3 + 1] = -60 + p * 110; pos[i * 3 + 2] = Math.sin(a) * r; const c = new THREE.Color(palette[i % palette.length]); colors[i * 3] = c.r; colors[i * 3 + 1] = c.g; colors[i * 3 + 2] = c.b; }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3)); geo.setAttribute('color', new THREE.BufferAttribute(colors, 3)); geo.setDrawRange(0, 0);
            return new THREE.Points(geo, new THREE.PointsMaterial({ size: 6.0, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true }));
        })();

        const hPoints = createLayer('heart', 8000), gPoints = createLayer('gift', 4000), ground = createLayer(null, 15000, true);
        scene.add(hPoints, gPoints, ground, spiralString);
        scene.add(new THREE.PointLight(0xFFD700, 1, 500));

        const starShape = new THREE.Shape();
        for (let i = 0; i < 10; i++) { const r = i % 2 === 0 ? 8 : 3.5; const a = (i / 10) * Math.PI * 2 - Math.PI / 2; if (i === 0) starShape.moveTo(Math.cos(a) * r, Math.sin(a) * r); else starShape.lineTo(Math.cos(a) * r, Math.sin(a) * r); }
        const star = new THREE.Mesh(new THREE.ExtrudeGeometry(starShape, { depth: 2, bevelEnabled: false }), new THREE.MeshStandardMaterial({ color: 0xFFFF00, emissive: 0xFF8C00, emissiveIntensity: 0.5, transparent: true, opacity: 0 }));
        star.position.set(0, 65, 0); star.rotation.set(0, 0, Math.PI); scene.add(star);
        const sLight = new THREE.PointLight(0xFFD700, 0, 200); sLight.position.set(0, 65, 0); scene.add(sLight);

        const snowGeo = new THREE.BufferGeometry(); const snowPos = new Float32Array(5000 * 3); for (let i = 0; i < 5000; i++) { snowPos[i * 3] = (Math.random() - 0.5) * 1000; snowPos[i * 3 + 1] = Math.random() * 1000 - 500; snowPos[i * 3 + 2] = (Math.random() - 0.5) * 1000; }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3)); const snowPoints = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xFFFFFF, size: 1.8, transparent: true, opacity: 0.8 })); scene.add(snowPoints);

        // --- ANIMATION LOOP ---
        function startTypewriter() { typewriter.innerHTML = ""; let i = 0; function type() { if (i < message.length) { typewriter.innerHTML += message.charAt(i) === "\n" ? "<br>" : message.charAt(i); i++; setTimeout(type, 50); } } type(); }
        window.closeLetter = () => { letterBox.style.display = 'none'; gsap.to(envelope.material, { opacity: 1, duration: 1 }); letterOpened = false; };

        function animate() {
            requestAnimationFrame(animate); if (!experienceStarted) return;
            const t = Date.now() * 0.003; const dist = camera.position.length();

            if (dist < 160 && !isMorphed) {
                isMorphed = true;
                gsap.to([hPoints.material.uniforms.uSurprise, gPoints.material.uniforms.uSurprise], { value: 1.0, duration: 2.0 });
                // Ẩn hoa mượt mà
                flowerGarden.children.forEach(fl => gsap.to(fl.scale, { x: 0, y: 0, z: 0, duration: 0.5 }));
                photoGroup.children.forEach(ph => gsap.to(ph.scale, { x: 0, y: 0, z: 0, duration: 0.5 }));
                gsap.to(lightAnimData, { count: 0, duration: 1.0, onUpdate: () => spiralString.geometry.setDrawRange(0, Math.floor(lightAnimData.count)) });
                gsap.to(star.material, { opacity: 0, duration: 0.5 });
                gsap.to('#loveText', { opacity: 1, duration: 1.5, delay: 1.8 });
                envelope.visible = true; gsap.to(envelope.material, { opacity: 1, duration: 1, delay: 2 });
            } else if (dist > 190 && isMorphed) {
                isMorphed = false; gsap.to('#loveText', { opacity: 0, duration: 0.5 });
                gsap.to([hPoints.material.uniforms.uSurprise, gPoints.material.uniforms.uSurprise], { value: 0.0, duration: 2.0, delay: 0.5 });
                // Cho hoa nở lại tuần tự (Stagger)
                flowerGarden.children.forEach((fl, i) => gsap.to(fl.scale, { x: 1, y: 1, z: 1, duration: 1, delay: 0.5 + i * 0.01, ease: "back.out(1.7)" }));
                photoGroup.children.forEach((ph, i) => gsap.to(ph.scale, { x: 1, y: 1, z: 1, duration: 1, delay: 0.8 + i * 0.1, ease: "back.out(1.7)" }));
                gsap.to(lightAnimData, { count: 350, duration: 3.0, delay: 1.0, onUpdate: () => spiralString.geometry.setDrawRange(0, Math.floor(lightAnimData.count)) });
                gsap.to(star.material, { opacity: 1, duration: 0.5, delay: 0.5 });
                gsap.to(envelope.material, { opacity: 0, duration: 0.5, onComplete: () => envelope.visible = false });
                letterBox.style.display = 'none'; letterOpened = false;
            }

            if (intro < 1.0) {
                intro += 0.0025; const p = Math.min(intro, 1.0);
                hPoints.material.uniforms.uProgress.value = p; gPoints.material.uniforms.uProgress.value = p; ground.material.uniforms.uProgress.value = p;
                if (p > 0.8) { const fade = (p - 0.8) * 5; if (!isMorphed) { star.material.opacity = fade; sLight.intensity = fade * 6; } document.getElementById('header').style.opacity = fade; }
                if (intro >= 1.0 && !treeFinished) { 
                    treeFinished = true; 
                    // HIỆU ỨNG HOA NỞ TUẦN TỰ (FIX GIẬT KHỰNG)
                    flowerGarden.children.forEach((fl, i) => {
                        gsap.to(fl.scale, { x: 1, y: 1, z: 1, duration: 1.5, delay: 0.5 + i * 0.01, ease: "back.out(1.7)" });
                    });
                    photoGroup.children.forEach((ph, i) => {
                        gsap.to(ph.scale, { x: 1, y: 1, z: 1, duration: 1.5, delay: 0.8 + i * 0.1, ease: "back.out(1.7)" });
                    });
                    gsap.to(lightAnimData, { count: 350, duration: 4.0, delay: 1.5, onUpdate: () => spiralString.geometry.setDrawRange(0, Math.floor(lightAnimData.count)) }); 
                }
            } else if (!isMorphed) { star.material.emissiveIntensity = 3.5 + Math.sin(t * 6) * 2; sLight.intensity = 6 + Math.sin(t * 6) * 3; }

            if (envelope.visible) { envelope.position.y = -35 + Math.sin(t * 2) * 2; envelope.lookAt(camera.position); }

            const sPos = snowPoints.geometry.attributes.position.array;
            for (let i = 0; i < 5000; i++) { sPos[i * 3 + 1] -= 0.8; if (sPos[i * 3 + 1] < -400) sPos[i * 3 + 1] = 600; }
            snowPoints.geometry.attributes.position.needsUpdate = true;
            const gPos = ground.geometry.attributes.position.array;
            for (let i = 0; i < 15000; i++) { gPos[i * 3 + 1] = -65 + Math.sin(gPos[i * 3] * 0.03 + t) * 3 + Math.cos(gPos[i * 3 + 2] * 0.03 + t) * 2; }
            ground.geometry.attributes.position.needsUpdate = true;

            hPoints.rotation.y += 0.001; gPoints.rotation.y -= 0.001; ground.rotation.y += 0.0005; flowerGarden.rotation.y += 0.0005; spiralString.rotation.y = hPoints.rotation.y;
            if (!focusedPhoto) { photoGroup.rotation.y += 0.0005; controls.update(); }
            renderer.render(scene, camera);
        }
        let intro = 0; const lightAnimData = { count: 0 };
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        animate();
    </script>
</body>

</html>